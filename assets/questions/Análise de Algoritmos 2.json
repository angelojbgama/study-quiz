[
  { 
    "quiz": "Análise de Algoritmos", 
    "question": "Se um algoritmo executa em tempo O(n) e outro em O(n log n), qual tende a ser mais rápido para entradas muito grandes?", 
    "answer": "O(n)", 
    "wrong1": "O(n log n)",
    "wrong2": "O(n^2)",
    "wrong3": "O(2^n)",
    "tags": "comparação",
    "explicacao": "Para n muito grande, n cresce mais lentamente do que n log n."
  },
  { 
    "quiz": "Análise de Algoritmos", 
    "question": "Por que constantes (como 2n ou n+10) são ignoradas na análise assintótica?", 
    "answer": "Porque não influenciam no crescimento para entradas muito grandes", 
    "wrong1": "Porque tornam o algoritmo constante",
    "wrong2": "Porque Big-O mede o tempo exato em segundos",
    "wrong3": "Porque só comparamos entradas pequenas",
    "tags": "conceitos",
    "explicacao": "Fatores e somas constantes são absorvidos pelo termo dominante."
  },
  { 
    "quiz": "Recursividade", 
    "question": "O que acontece se uma função recursiva não tiver caso base?", 
    "answer": "Ela entra em recursão infinita até estourar a pilha de execução (StackOverflow)", 
    "wrong1": "Ela se torna mais rápida",
    "wrong2": "Ela sempre termina em O(1)",
    "wrong3": "O compilador converte automaticamente em um loop finito",
    "tags": "erros"
  },
  { 
    "quiz": "Recursividade", 
    "question": "Qual é a vantagem da recursão em problemas como percorrer árvores?", 
    "answer": "Simplifica a implementação, refletindo a estrutura hierárquica da árvore", 
    "wrong1": "Sempre usa menos memória do que iteração",
    "wrong2": "Garante melhor desempenho em todos os casos",
    "wrong3": "Evita o uso de chamadas de função",
    "tags": "aplicações"
  },
  { 
    "quiz": "Ordenação Avançada", 
    "question": "Qual algoritmo de ordenação é usado em muitas bibliotecas modernas, como no Python (sort)?", 
    "answer": "Timsort (mistura de Merge Sort e Insertion Sort)", 
    "wrong1": "Quick Sort puro",
    "wrong2": "Heap Sort",
    "wrong3": "Bubble Sort",
    "tags": "aplicações",
    "explicacao": "Timsort combina runs já ordenadas (Insertion) com mesclagem (Merge)."
  },
  { 
    "quiz": "Ordenação Avançada", 
    "question": "Entre Quick Sort e Merge Sort, qual precisa de memória auxiliar extra?", 
    "answer": "Merge Sort", 
    "wrong1": "Quick Sort",
    "wrong2": "Ambos não precisam",
    "wrong3": "Nenhum precisa",
    "tags": "comparação",
    "explicacao": "Merge Sort usa vetor auxiliar; Quick Sort costuma ser in-place."
  },
  { 
    "quiz": "Árvores Binárias e AVL", 
    "question": "Por que usamos árvores balanceadas como AVL em vez de BST simples?", 
    "answer": "Para garantir sempre buscas O(log n), evitando que a árvore vire uma lista", 
    "wrong1": "Para reduzir o uso de memória",
    "wrong2": "Para permitir ciclos na estrutura",
    "wrong3": "Para garantir inserções em O(1)",
    "tags": "aplicações"
  },
  { 
    "quiz": "Árvores Binárias e AVL", 
    "question": "Qual é a principal diferença entre uma AVL e uma Red-Black Tree?", 
    "answer": "A AVL é mais rigidamente balanceada, a Red-Black é menos balanceada mas tem inserções/remoções mais rápidas", 
    "wrong1": "AVL permite chaves duplicadas e Red-Black não",
    "wrong2": "Red-Black não usa rotações",
    "wrong3": "AVL usa cores nos nós para balancear",
    "tags": "comparação"
  },
  { 
    "quiz": "Grafos", 
    "question": "Qual algoritmo você usaria em uma rede social para sugerir amigos em comum?", 
    "answer": "BFS ou DFS para encontrar conexões de 2 níveis (amigos de amigos)", 
    "wrong1": "Kruskal",
    "wrong2": "Dijkstra",
    "wrong3": "A*",
    "tags": "aplicações",
    "explicacao": "BFS por camadas encontra vizinhos a distância 2 de forma natural."
  },
  { 
    "quiz": "Grafos", 
    "question": "Qual algoritmo é mais indicado para calcular rotas em GPS (estradas com distâncias positivas)?", 
    "answer": "Dijkstra", 
    "wrong1": "Bellman-Ford",
    "wrong2": "Floyd-Warshall",
    "wrong3": "Prim",
    "tags": "aplicações",
    "explicacao": "Dijkstra resolve caminho mínimo de uma fonte com pesos não negativos."
  },
  { 
    "quiz": "Grafos", 
    "question": "Se quisermos planejar a rede elétrica de uma cidade com menor custo, qual algoritmo usaríamos?", 
    "answer": "Kruskal ou Prim (árvore geradora mínima)", 
    "wrong1": "Dijkstra",
    "wrong2": "BFS",
    "wrong3": "Bellman-Ford",
    "tags": "aplicações"
  },
  { 
    "quiz": "Grafos", 
    "question": "Se precisarmos verificar se um grafo tem ciclos, qual algoritmo é adequado?", 
    "answer": "DFS", 
    "wrong1": "Dijkstra",
    "wrong2": "Prim",
    "wrong3": "Kruskal",
    "tags": "aplicações"
  }
]
