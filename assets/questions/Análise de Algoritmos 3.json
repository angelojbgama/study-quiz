[
  { 
    "quiz": "Análise de Algoritmos", 
    "question": "Qual é a complexidade do seguinte código?\n\nfor i in range(n):\n    j = n\n    while j > 0:\n        j = j // 2\n        print(i, j)", 
    "answer": "O(n log n)", 
    "wrong1": "O(n)",
    "wrong2": "O(n²)",
    "wrong3": "O(log n)",
    "tags": "código",
    "explicacao": "O laço externo roda n vezes e o interno executa ~log n por iteração (divisão por 2), totalizando n·log n."
  },
  { 
    "quiz": "Análise de Algoritmos", 
    "question": "Qual é a complexidade do seguinte código?\n\nfor i in range(n):\n    for j in range(i):\n        print(i, j)", 
    "answer": "O(n²)", 
    "wrong1": "O(n)",
    "wrong2": "O(n log n)",
    "wrong3": "O(n³)",
    "tags": "código",
    "explicacao": "A soma 0+1+2+…+(n−1) é n(n−1)/2, que é Θ(n²)."
  },
  { 
    "quiz": "Análise de Algoritmos", 
    "question": "Qual é a complexidade do seguinte código?\n\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            print(i, j, k)", 
    "answer": "O(n³)", 
    "wrong1": "O(n²)",
    "wrong2": "O(n log n)",
    "wrong3": "O(2^n)",
    "tags": "código",
    "explicacao": "Três laços aninhados de 0..n−1 multiplicam: n·n·n = n³."
  },
  { 
    "quiz": "Recursividade", 
    "question": "Qual é a complexidade da função abaixo?\n\ndef func(n):\n    if n <= 1:\n        return 1\n    return func(n-1) + func(n-1)", 
    "answer": "O(2^n)", 
    "wrong1": "O(n)",
    "wrong2": "O(n log n)",
    "wrong3": "O(n²)",
    "tags": "código",
    "explicacao": "T(n)=2·T(n−1)+O(1) gera árvore binária de chamadas, com ~2^n folhas."
  },
  { 
    "quiz": "Recursividade", 
    "question": "O que acontece com a função abaixo?\n\ndef f(n):\n    if n == 0:\n        return 0\n    else:\n        return f(n+1)", 
    "answer": "Entra em recursão infinita até estourar a pilha (StackOverflow)", 
    "wrong1": "Termina retornando n",
    "wrong2": "Converge para 0 após algumas chamadas",
    "wrong3": "É otimizada para loop e finaliza sempre",
    "tags": "erros",
    "explicacao": "Para n≠0, o parâmetro cresce sem alcançar o caso base; não há condição de parada."
  },
  { 
    "quiz": "Ordenação Avançada", 
    "question": "Se o Quick Sort escolher sempre o pior pivô, qual é sua complexidade?", 
    "answer": "O(n²)", 
    "wrong1": "O(n log n)",
    "wrong2": "O(n)",
    "wrong3": "O(2^n)",
    "tags": "complexidade",
    "explicacao": "Particionamentos muito desbalanceados levam a somatório ~n+(n−1)+…+1 = Θ(n²)."
  },
  { 
    "quiz": "Ordenação Avançada", 
    "question": "Qual é a vantagem do Heap Sort em relação ao Merge Sort?", 
    "answer": "Não precisa de memória auxiliar extra", 
    "wrong1": "É sempre mais rápido em média",
    "wrong2": "É estável por padrão",
    "wrong3": "Tem melhor caso O(1)",
    "tags": "comparação",
    "explicacao": "Heap Sort é in-place (O(1) extra), enquanto Merge Sort requer O(n) de memória auxiliar."
  },
  { 
    "quiz": "Árvores Binárias e AVL", 
    "question": "O que acontece se inserirmos os valores 1,2,3,4,5 em uma BST simples?", 
    "answer": "A árvore degenera em uma lista ligada (desbalanceada)", 
    "wrong1": "Permanece perfeitamente balanceada",
    "wrong2": "A altura fica O(log n) garantida",
    "wrong3": "Sempre realiza rotações para balancear",
    "tags": "aplicações",
    "explicacao": "Inserções em ordem crescente na BST simples criam uma corrente à direita (altura ~n)."
  },
  { 
    "quiz": "Árvores Binárias e AVL", 
    "question": "Qual é a sequência de saída da travessia pós-ordem da árvore abaixo?\n\n    2\n   / \\\n  1   3", 
    "answer": "1, 3, 2", 
    "wrong1": "2, 1, 3",
    "wrong2": "1, 2, 3",
    "wrong3": "2, 3, 1",
    "tags": "percursos",
    "explicacao": "Pós-ordem: esquerda, direita, raiz. Para (2 (1,3)) → 1, 3, 2."
  },
  { 
    "quiz": "Grafos", 
    "question": "Qual algoritmo detecta ciclos em um grafo direcionado usando pilha de recursão?", 
    "answer": "DFS", 
    "wrong1": "BFS",
    "wrong2": "Kruskal",
    "wrong3": "Prim",
    "tags": "percursos",
    "explicacao": "DFS com marcação de nós em ‘pilha’ encontra arestas de retorno em grafos direcionados."
  },
  { 
    "quiz": "Grafos", 
    "question": "Qual estrutura de dados é usada em Dijkstra para escolher sempre o próximo vértice com menor distância?", 
    "answer": "Fila de prioridade (heap)", 
    "wrong1": "Fila (queue) simples",
    "wrong2": "Pilha (stack)",
    "wrong3": "Deque",
    "tags": "caminhos mínimos",
    "explicacao": "Usa min-heap para extrair o vértice de menor distância em O(log n)."
  },
  { 
    "quiz": "Grafos", 
    "question": "Se quisermos saber se um grafo é conexo (todos os vértices estão ligados), qual algoritmo podemos usar?", 
    "answer": "BFS ou DFS", 
    "wrong1": "Dijkstra",
    "wrong2": "Kruskal",
    "wrong3": "Ordenação topológica",
    "tags": "aplicações",
    "explicacao": "BFS/DFS a partir de um vértice alcança todos os outros se o grafo for conexo."
  }
]
